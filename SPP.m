function [pyramid_fvec, pyramid_pool] = SPP(fmap, pyramid)
% SPP: Spatial Pyramid Pooling
% Spatial Pyramid Pooling in Deep Convolutional Networks for Visual Recognition
% Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun
%
% Spatial Pyramid Pooling (SPP) is a technique used in convolutional neural
% networks (CNNs) to aggregate information from different regions of an
% input image, regardless of its size or aspect ratio. It was introduced to
% address the challenge of handling images with varying sizes or scales in
% a fixed-size CNN.
% 
% The idea behind SPP is to divide the feature maps generated by the
% convolutional layers into a set of fixed-size grids and then perform
% pooling operations within each grid independently. This enables the
% network to capture information at multiple scales and locations within
% the image, making it more robust to variations in the field of view.
%
% By applying spatial pyramid pooling, the CNN can effectively capture both
% local and global context information from the image, regardless of its
% size or aspect ratio. This makes the features more robust and less
% dependent on the specific field of view of the input image.
% 
% SPP has been used in various computer vision tasks, such as object
% recognition, image segmentation, and scene understanding. It helps to
% address the challenge of handling images with different scales or aspect
% ratios, providing a more flexible and powerful representation for the
% CNN.
%
% ------------------------------------------------------------------------
% Here's a step-by-step explanation of how spatial pyramid pooling works:
% 
% 1. Given an input image, pass it through the convolutional layers of a
% CNN to obtain feature maps.
% 2. Divide each feature map into a set of fixed-size grids (e.g., 1x1,
% 2x2, 3x3 grids).
% 3. Apply pooling operations (such as max pooling) separately within each
% grid. The pooling operation reduces the information within each grid to a
% fixed-size representation.
% 4. Concatenate the pooled features obtained from all grids together to
% form a fixed-length feature vector.
% 5. Feed the concatenated feature vector into subsequent layers (e.g.,
% fully connected layers) for classification or further processing.
%
% ------------------------------------------------------------------------
% example:
% img = imread('cameraman.tif');
% img = repmat(img,[1,1,3]);
% 
% net = alexnet();
% fmap = activations(net, img, 'relu5');
% 
% pyramid{1}.pool_operator = 'max';
% pyramid{1}.pool_size = [4,4];
% pyramid{1}.stride = [2,2];
% 
% pyramid{2}.pool_operator = 'max';
% pyramid{2}.pool_size = [3,3];
% pyramid{2}.stride = [1,1];
% 
% pyramid{3}.pool_operator = 'max';
% pyramid{3}.pool_size = [2,2];
% pyramid{3}.stride = [1,1];
% 
% pyramid_fmap = SPP(fmap, pyramid);

pyramid_pool = cell(size(pyramid));
mumber_of_features = 0;
for pyramid_level = 1:length(pyramid)
    pyramid_pool{pyramid_level} = apply_pool(fmap, ...
                                             pyramid{pyramid_level}.pool_operator, ...
                                             pyramid{pyramid_level}.pool_size, ...
                                             pyramid{pyramid_level}.stride);
    
    mumber_of_features = mumber_of_features + numel(pyramid_pool{pyramid_level});
end

indx = 1;
pyramid_fvec = zeros(1,mumber_of_features);
for pyramid_level = 1:length(pyramid)
    pyramid_fvec(indx : indx-1+numel(pyramid_pool{pyramid_level})) = pyramid_pool{pyramid_level}(:)';
    indx = indx + numel(pyramid_pool{pyramid_level});
end
end

function [pool] = apply_pool(fmap, pool_operator, pool_size, stride)

pad_size = [round(pool_size/2), 0];
switch lower(pool_operator)
    case 'max'
        paded_fmap = padarray(fmap, pad_size, min(fmap,[],'all'));
    case 'min'
        paded_fmap = padarray(fmap, pad_size, max(fmap,[],'all'));
    case 'average'
        paded_fmap = padarray(fmap, pad_size, mean(fmap,'all'));
end

[row_size, col_size, filter_numbers] = size(paded_fmap);
pool = zeros([round(size(fmap,1:2)./stride), filter_numbers]);
r_tmp = 0;

for r = 1 : stride(1) : row_size - pool_size(1)
    
    r_tmp = r_tmp + 1;
    c_tmp = 0;
    
    for c = 1 : stride(2) : col_size - pool_size(2)
        c_tmp = c_tmp + 1;

        win = paded_fmap(r:r+pool_size(1)-1, c:c+pool_size(2)-1, :);
        
        switch lower(pool_operator)
            case 'max'
                pool(r_tmp, c_tmp, :) = max(win,[],[1 2]);
            case 'min'
                pool(r_tmp, c_tmp, :) = min(win,[],[1 2]);
            case 'average'
                pool(r_tmp, c_tmp, :) = mean(win,[1 2]);
        end
    end
end
end
